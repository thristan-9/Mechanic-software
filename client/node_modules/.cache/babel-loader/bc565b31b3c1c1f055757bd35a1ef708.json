{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { useCallback, useEffect, useState } from \"react\";\nimport { getFixedPosition, getViewportSize, useResizeListener, useScrollListener } from \"@react-md/utils\";\n\nfunction getFixedTo(fixedTo) {\n  if (!fixedTo) {\n    return null;\n  }\n\n  if (typeof fixedTo === \"string\") {\n    return document.getElementById(fixedTo) || document.querySelector(fixedTo);\n  }\n\n  if (typeof fixedTo === \"function\") {\n    return fixedTo();\n  }\n\n  if (\"current\" in fixedTo) {\n    return fixedTo.current;\n  }\n\n  return fixedTo;\n}\n/**\n * This hook is used to automatically handle fixed positioning when an element\n * is used alongside a `Transition` from `react-transition-group`. This will\n * provide merged `onEnter`, `onEntering`, `onEntered`, and `onExited` handlers\n * to pass down as well as the current style object to apply to the element.\n *\n * Until the element has been removed from the DOM and is visible, the position\n * will automatically update when the user scrolls or resizes the screen.\n *\n * @remarks\n *\n * It is recommended to start the exit animation when that happens though.\n */\n\n\nexport function useFixedPositioning(_a) {\n  var propStyle = _a.style,\n      onEnter = _a.onEnter,\n      onEntering = _a.onEntering,\n      onEntered = _a.onEntered,\n      onExited = _a.onExited,\n      fixedTo = _a.fixedTo,\n      getOptions = _a.getOptions,\n      onResize = _a.onResize,\n      onScroll = _a.onScroll,\n      _b = _a.anchor,\n      currentAnchor = _b === void 0 ? {} : _b,\n      initialX = _a.initialX,\n      initialY = _a.initialY,\n      _c = _a.xMargin,\n      xMargin = _c === void 0 ? 0 : _c,\n      _d = _a.vwMargin,\n      vwMargin = _d === void 0 ? 16 : _d,\n      _e = _a.yMargin,\n      yMargin = _e === void 0 ? 0 : _e,\n      _f = _a.vhMargin,\n      vhMargin = _f === void 0 ? 16 : _f,\n      _g = _a.width,\n      width = _g === void 0 ? \"auto\" : _g,\n      onPositionChange = _a.onPositionChange,\n      _h = _a.transformOrigin,\n      transformOrigin = _h === void 0 ? false : _h,\n      _j = _a.preventOverlap,\n      preventOverlap = _j === void 0 ? false : _j,\n      _k = _a.disableSwapping,\n      disableSwapping = _k === void 0 ? false : _k,\n      _l = _a.disableVHBounds,\n      disableVHBounds = _l === void 0 ? false : _l;\n\n  var _m = useState(),\n      style = _m[0],\n      setStyle = _m[1];\n\n  var _o = useState(null),\n      element = _o[0],\n      setElement = _o[1];\n\n  var updateStyle = useCallback(function (nextElement) {\n    var node = nextElement !== null && nextElement !== void 0 ? nextElement : element;\n\n    if (typeof nextElement !== \"undefined\") {\n      setElement(nextElement);\n    }\n\n    if (!node) {\n      return;\n    }\n\n    var anchor = {\n      x: currentAnchor.x || \"center\",\n      y: currentAnchor.y || \"below\"\n    };\n    var overrides = typeof getOptions === \"function\" ? getOptions(node) : {};\n\n    var opts = __assign({\n      initialX: initialX,\n      initialY: initialY,\n      xMargin: xMargin,\n      vwMargin: vwMargin,\n      yMargin: yMargin,\n      vhMargin: vhMargin,\n      width: width,\n      transformOrigin: transformOrigin,\n      preventOverlap: preventOverlap,\n      disableSwapping: disableSwapping,\n      disableVHBounds: disableVHBounds,\n      anchor: anchor,\n      container: getFixedTo(fixedTo),\n      element: node\n    }, overrides);\n\n    var _a = getFixedPosition(opts),\n        style = _a.style,\n        actualX = _a.actualX,\n        actualY = _a.actualY;\n\n    var actual = {\n      x: actualX,\n      y: actualY\n    };\n\n    if (onPositionChange && (anchor.x !== actual.x || anchor.y !== actual.y)) {\n      onPositionChange(anchor, actual);\n    }\n\n    setStyle(style);\n  }, [currentAnchor.x, currentAnchor.y, disableSwapping, disableVHBounds, fixedTo, getOptions, initialX, initialY, onPositionChange, preventOverlap, transformOrigin, vhMargin, vwMargin, width, xMargin, yMargin, element]);\n  var handleEnter = useCallback(function (node, appear) {\n    if (onEnter) {\n      onEnter(node, appear);\n    }\n\n    updateStyle(node);\n  }, [onEnter, updateStyle]);\n  var handleEntering = useCallback(function (node, appear) {\n    if (onEntering) {\n      onEntering(node, appear);\n    }\n\n    updateStyle(node);\n  }, [onEntering, updateStyle]);\n  var handleEntered = useCallback(function (node, appear) {\n    if (onEntered) {\n      onEntered(node, appear);\n    }\n\n    updateStyle(node);\n  }, [onEntered, updateStyle]);\n  var handleExited = useCallback(function (node) {\n    if (onExited) {\n      onExited(node);\n    }\n\n    setElement(null);\n  }, [onExited]);\n  useResizeListener({\n    enabled: !!element,\n    onResize: function (event) {\n      if (onResize) {\n        onResize(event);\n      }\n\n      updateStyle();\n    }\n  });\n  useScrollListener({\n    enabled: !!element,\n    onScroll: function (event) {\n      if (onScroll) {\n        var container = getFixedTo(fixedTo);\n        var containerRect = container && container.getBoundingClientRect();\n        var elementRect = element && element.getBoundingClientRect();\n        var visible = false;\n\n        if (containerRect && elementRect) {\n          var vh = getViewportSize(\"height\");\n          var vw = getViewportSize(\"width\");\n          var top_1 = Math.min(elementRect.top, containerRect.top);\n          var right = Math.max(elementRect.right, containerRect.right);\n          var bottom = Math.max(elementRect.bottom, containerRect.bottom);\n          var left = Math.min(elementRect.left, containerRect.left);\n          visible = bottom >= 0 && top_1 <= vh && right >= 0 && left <= vw;\n        }\n\n        onScroll(event, {\n          element: element,\n          fixedTo: container,\n          visible: visible\n        });\n      }\n\n      updateStyle();\n    }\n  });\n  useEffect(function () {\n    updateStyle(); // Need to only update when the initialX and initialY values are changed.\n    // If this is triggered each time the updateStyle is changed, it causes an\n    // infinite loop.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [initialX, initialY]);\n  return {\n    style: __assign(__assign({}, style), propStyle),\n    updateStyle: updateStyle,\n    onEnter: handleEnter,\n    onEntering: handleEntering,\n    onEntered: handleEntered,\n    onExited: handleExited\n  };\n}","map":{"version":3,"sources":["../src/useFixedPositioning.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { useCallback, useEffect, useState, } from \"react\";\nimport { getFixedPosition, getViewportSize, useResizeListener, useScrollListener, } from \"@react-md/utils\";\nfunction getFixedTo(fixedTo) {\n    if (!fixedTo) {\n        return null;\n    }\n    if (typeof fixedTo === \"string\") {\n        return (document.getElementById(fixedTo) ||\n            document.querySelector(fixedTo));\n    }\n    if (typeof fixedTo === \"function\") {\n        return fixedTo();\n    }\n    if (\"current\" in fixedTo) {\n        return fixedTo.current;\n    }\n    return fixedTo;\n}\n/**\n * This hook is used to automatically handle fixed positioning when an element\n * is used alongside a `Transition` from `react-transition-group`. This will\n * provide merged `onEnter`, `onEntering`, `onEntered`, and `onExited` handlers\n * to pass down as well as the current style object to apply to the element.\n *\n * Until the element has been removed from the DOM and is visible, the position\n * will automatically update when the user scrolls or resizes the screen.\n *\n * @remarks\n *\n * It is recommended to start the exit animation when that happens though.\n */\nexport function useFixedPositioning(_a) {\n    var propStyle = _a.style, onEnter = _a.onEnter, onEntering = _a.onEntering, onEntered = _a.onEntered, onExited = _a.onExited, fixedTo = _a.fixedTo, getOptions = _a.getOptions, onResize = _a.onResize, onScroll = _a.onScroll, _b = _a.anchor, currentAnchor = _b === void 0 ? {} : _b, initialX = _a.initialX, initialY = _a.initialY, _c = _a.xMargin, xMargin = _c === void 0 ? 0 : _c, _d = _a.vwMargin, vwMargin = _d === void 0 ? 16 : _d, _e = _a.yMargin, yMargin = _e === void 0 ? 0 : _e, _f = _a.vhMargin, vhMargin = _f === void 0 ? 16 : _f, _g = _a.width, width = _g === void 0 ? \"auto\" : _g, onPositionChange = _a.onPositionChange, _h = _a.transformOrigin, transformOrigin = _h === void 0 ? false : _h, _j = _a.preventOverlap, preventOverlap = _j === void 0 ? false : _j, _k = _a.disableSwapping, disableSwapping = _k === void 0 ? false : _k, _l = _a.disableVHBounds, disableVHBounds = _l === void 0 ? false : _l;\n    var _m = useState(), style = _m[0], setStyle = _m[1];\n    var _o = useState(null), element = _o[0], setElement = _o[1];\n    var updateStyle = useCallback(function (nextElement) {\n        var node = nextElement !== null && nextElement !== void 0 ? nextElement : element;\n        if (typeof nextElement !== \"undefined\") {\n            setElement(nextElement);\n        }\n        if (!node) {\n            return;\n        }\n        var anchor = {\n            x: currentAnchor.x || \"center\",\n            y: currentAnchor.y || \"below\",\n        };\n        var overrides = typeof getOptions === \"function\" ? getOptions(node) : {};\n        var opts = __assign({ initialX: initialX,\n            initialY: initialY,\n            xMargin: xMargin,\n            vwMargin: vwMargin,\n            yMargin: yMargin,\n            vhMargin: vhMargin,\n            width: width,\n            transformOrigin: transformOrigin,\n            preventOverlap: preventOverlap,\n            disableSwapping: disableSwapping,\n            disableVHBounds: disableVHBounds,\n            anchor: anchor, container: getFixedTo(fixedTo), element: node }, overrides);\n        var _a = getFixedPosition(opts), style = _a.style, actualX = _a.actualX, actualY = _a.actualY;\n        var actual = { x: actualX, y: actualY };\n        if (onPositionChange &&\n            (anchor.x !== actual.x || anchor.y !== actual.y)) {\n            onPositionChange(anchor, actual);\n        }\n        setStyle(style);\n    }, [\n        currentAnchor.x,\n        currentAnchor.y,\n        disableSwapping,\n        disableVHBounds,\n        fixedTo,\n        getOptions,\n        initialX,\n        initialY,\n        onPositionChange,\n        preventOverlap,\n        transformOrigin,\n        vhMargin,\n        vwMargin,\n        width,\n        xMargin,\n        yMargin,\n        element,\n    ]);\n    var handleEnter = useCallback(function (node, appear) {\n        if (onEnter) {\n            onEnter(node, appear);\n        }\n        updateStyle(node);\n    }, [onEnter, updateStyle]);\n    var handleEntering = useCallback(function (node, appear) {\n        if (onEntering) {\n            onEntering(node, appear);\n        }\n        updateStyle(node);\n    }, [onEntering, updateStyle]);\n    var handleEntered = useCallback(function (node, appear) {\n        if (onEntered) {\n            onEntered(node, appear);\n        }\n        updateStyle(node);\n    }, [onEntered, updateStyle]);\n    var handleExited = useCallback(function (node) {\n        if (onExited) {\n            onExited(node);\n        }\n        setElement(null);\n    }, [onExited]);\n    useResizeListener({\n        enabled: !!element,\n        onResize: function (event) {\n            if (onResize) {\n                onResize(event);\n            }\n            updateStyle();\n        },\n    });\n    useScrollListener({\n        enabled: !!element,\n        onScroll: function (event) {\n            if (onScroll) {\n                var container = getFixedTo(fixedTo);\n                var containerRect = container && container.getBoundingClientRect();\n                var elementRect = element && element.getBoundingClientRect();\n                var visible = false;\n                if (containerRect && elementRect) {\n                    var vh = getViewportSize(\"height\");\n                    var vw = getViewportSize(\"width\");\n                    var top_1 = Math.min(elementRect.top, containerRect.top);\n                    var right = Math.max(elementRect.right, containerRect.right);\n                    var bottom = Math.max(elementRect.bottom, containerRect.bottom);\n                    var left = Math.min(elementRect.left, containerRect.left);\n                    visible = bottom >= 0 && top_1 <= vh && right >= 0 && left <= vw;\n                }\n                onScroll(event, {\n                    element: element,\n                    fixedTo: container,\n                    visible: visible,\n                });\n            }\n            updateStyle();\n        },\n    });\n    useEffect(function () {\n        updateStyle();\n        // Need to only update when the initialX and initialY values are changed.\n        // If this is triggered each time the updateStyle is changed, it causes an\n        // infinite loop.\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [initialX, initialY]);\n    return {\n        style: __assign(__assign({}, style), propStyle),\n        updateStyle: updateStyle,\n        onEnter: handleEnter,\n        onEntering: handleEntering,\n        onEntered: handleEntered,\n        onExited: handleExited,\n    };\n}\n//# sourceMappingURL=useFixedPositioning.js.map"]},"metadata":{},"sourceType":"module"}