{"ast":null,"code":"import { useCallback, useRef, useState } from \"react\";\n/**\n * This hook is used to handle the different states for the text field based on\n * the current value and user interaction.\n *\n * @internal\n * @remarks \\@since 2.5.2\n */\n\nexport function useFieldStates(_a) {\n  var onBlur = _a.onBlur,\n      onFocus = _a.onFocus,\n      onChange = _a.onChange,\n      value = _a.value,\n      defaultValue = _a.defaultValue;\n\n  var _b = useState(false),\n      focused = _b[0],\n      setFocused = _b[1];\n\n  var _c = useState(function () {\n    if (typeof value === \"undefined\") {\n      return typeof defaultValue !== \"undefined\" && defaultValue.length > 0;\n    }\n\n    return value.length > 0;\n  }),\n      valued = _c[0],\n      setValued = _c[1];\n\n  var handleBlur = useCallback(function (event) {\n    if (onBlur) {\n      onBlur(event);\n    }\n\n    setFocused(false);\n    var input = event.currentTarget;\n\n    if (input.getAttribute(\"type\") === \"number\") {\n      input.checkValidity();\n      setValued(input.validity.badInput || (value !== null && value !== void 0 ? value : input.value).length > 0);\n    }\n  }, [onBlur, value]);\n  var handleFocus = useCallback(function (event) {\n    if (onFocus) {\n      onFocus(event);\n    }\n\n    setFocused(true);\n  }, [onFocus]);\n  var handleChange = useCallback(function (event) {\n    if (onChange) {\n      onChange(event);\n    }\n\n    var input = event.currentTarget;\n\n    if (input.getAttribute(\"type\") === \"number\") {\n      input.checkValidity();\n      /* istanbul ignore next */\n\n      if (input.validity.badInput) {\n        return;\n      }\n    }\n\n    setValued(input.value.length > 0);\n  }, [onChange]); // another way to handle this could be to just make the `valued` state derived\n  // based on the `value`, but it gets wonky for number fields. This technically\n  // still fails right now for number fields if you don't use the\n  // `useNumberField` hook since the `value` will be set back to the empty\n  // string on invalid numbers.\n\n  var prevValue = useRef(value);\n\n  if (prevValue.current !== value && typeof value === \"string\") {\n    prevValue.current = value;\n    setValued(value.length > 0);\n  }\n\n  return {\n    valued: valued,\n    focused: focused,\n    onBlur: handleBlur,\n    onFocus: handleFocus,\n    onChange: handleChange\n  };\n}","map":{"version":3,"sources":["../src/useFieldStates.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { useCallback, useRef, useState, } from \"react\";\n/**\n * This hook is used to handle the different states for the text field based on\n * the current value and user interaction.\n *\n * @internal\n * @remarks \\@since 2.5.2\n */\nexport function useFieldStates(_a) {\n    var onBlur = _a.onBlur, onFocus = _a.onFocus, onChange = _a.onChange, value = _a.value, defaultValue = _a.defaultValue;\n    var _b = useState(false), focused = _b[0], setFocused = _b[1];\n    var _c = useState(function () {\n        if (typeof value === \"undefined\") {\n            return typeof defaultValue !== \"undefined\" && defaultValue.length > 0;\n        }\n        return value.length > 0;\n    }), valued = _c[0], setValued = _c[1];\n    var handleBlur = useCallback(function (event) {\n        if (onBlur) {\n            onBlur(event);\n        }\n        setFocused(false);\n        var input = event.currentTarget;\n        if (input.getAttribute(\"type\") === \"number\") {\n            input.checkValidity();\n            setValued(input.validity.badInput || (value !== null && value !== void 0 ? value : input.value).length > 0);\n        }\n    }, [onBlur, value]);\n    var handleFocus = useCallback(function (event) {\n        if (onFocus) {\n            onFocus(event);\n        }\n        setFocused(true);\n    }, [onFocus]);\n    var handleChange = useCallback(function (event) {\n        if (onChange) {\n            onChange(event);\n        }\n        var input = event.currentTarget;\n        if (input.getAttribute(\"type\") === \"number\") {\n            input.checkValidity();\n            /* istanbul ignore next */\n            if (input.validity.badInput) {\n                return;\n            }\n        }\n        setValued(input.value.length > 0);\n    }, [onChange]);\n    // another way to handle this could be to just make the `valued` state derived\n    // based on the `value`, but it gets wonky for number fields. This technically\n    // still fails right now for number fields if you don't use the\n    // `useNumberField` hook since the `value` will be set back to the empty\n    // string on invalid numbers.\n    var prevValue = useRef(value);\n    if (prevValue.current !== value && typeof value === \"string\") {\n        prevValue.current = value;\n        setValued(value.length > 0);\n    }\n    return {\n        valued: valued,\n        focused: focused,\n        onBlur: handleBlur,\n        onFocus: handleFocus,\n        onChange: handleChange,\n    };\n}\n//# sourceMappingURL=useFieldStates.js.map"]},"metadata":{},"sourceType":"module"}