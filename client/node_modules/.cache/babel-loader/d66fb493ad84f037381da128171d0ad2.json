{"ast":null,"code":"var __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\n\n\nvar VALIDITY_STATE_KEYS = [\"badInput\", \"customError\", \"patternMismatch\", \"rangeOverflow\", \"rangeUnderflow\", \"stepMismatch\", \"tooLong\", \"tooShort\", \"typeMismatch\", \"valueMissing\"];\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\n\nexport var RECOMMENDED_STATE_KEYS = [\"badInput\", \"tooLong\", \"valueMissing\"];\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\n\nexport var RECOMMENDED_NUMBER_STATE_KEYS = __spreadArray(__spreadArray([], RECOMMENDED_STATE_KEYS), [\"rangeOverflow\", \"rangeUnderflow\", \"tooShort\", \"typeMismatch\"]);\n/**\n * The validation message is actually kind of weird since it's possible for a\n * form element to have multiple errors at once. The validation message will be\n * the first error that appears, so need to make sure that the first error is\n * one of the recommended state keys so the message appears for only those types\n * of errors.\n *\n * @internal\n * @remarks \\@since 2.5.0\n */\n\nvar isRecommended = function (validity, isNumber) {\n  var errorable = isNumber ? RECOMMENDED_NUMBER_STATE_KEYS : RECOMMENDED_STATE_KEYS;\n  return VALIDITY_STATE_KEYS.every(function (key) {\n    var errored = validity[key];\n    return !errored || errorable.includes(key);\n  });\n};\n/**\n * The default implementation for getting an error message for the `TextField`\n * or `TextArea` components that relies on the behavior of the\n * {@link ChangeValidationBehavior}\n *\n * @remarks \\@since 2.5.0\n */\n\n\nexport var defaultGetErrorMessage = function (_a) {\n  var isBlurEvent = _a.isBlurEvent,\n      validity = _a.validity,\n      validationMessage = _a.validationMessage,\n      validateOnChange = _a.validateOnChange;\n\n  if (isBlurEvent || !validationMessage || validateOnChange === true) {\n    return validationMessage;\n  }\n\n  if (!validateOnChange) {\n    return \"\";\n  }\n\n  if (validateOnChange === \"recommended\" || validateOnChange === \"number-recommended\") {\n    return isRecommended(validity, validateOnChange === \"number-recommended\") ? validationMessage : \"\";\n  }\n\n  var keys = typeof validateOnChange === \"string\" ? [validateOnChange] : validateOnChange;\n  return keys.length && VALIDITY_STATE_KEYS.some(function (key) {\n    return validity[key] && keys.includes(key);\n  }) ? validationMessage : \"\";\n};","map":{"version":3,"sources":["../../src/text-field/getErrorMessage.ts"],"names":[],"mappings":";;;;;AA+EA;;;AAGG;;;AACH,IAAM,mBAAmB,GAAqC,CAC5D,UAD4D,EAE5D,aAF4D,EAG5D,iBAH4D,EAI5D,eAJ4D,EAK5D,gBAL4D,EAM5D,cAN4D,EAO5D,SAP4D,EAQ5D,UAR4D,EAS5D,cAT4D,EAU5D,cAV4D,CAA9D;AAaA;;;AAGG;;AACH,OAAO,IAAM,sBAAsB,GAAqC,CACtE,UADsE,EAEtE,SAFsE,EAGtE,cAHsE,CAAjE;AAMP;;;AAGG;;AACH,OAAO,IAAM,6BAA6B,GAAA,aAAA,CAAA,aAAA,CAAA,EAAA,EACrC,sBADqC,CAAA,EACf,CACzB,eADyB,EAEzB,gBAFyB,EAGzB,UAHyB,EAIzB,cAJyB,CADe,CAAnC;AAQP;;;;;;;;;AASG;;AACH,IAAM,aAAa,GAAG,UAAC,QAAD,EAA0B,QAA1B,EAA2C;AAC/D,MAAM,SAAS,GAAG,QAAQ,GACtB,6BADsB,GAEtB,sBAFJ;AAIA,SAAO,mBAAmB,CAAC,KAApB,CAA0B,UAAC,GAAD,EAAI;AACnC,QAAM,OAAO,GAAG,QAAQ,CAAC,GAAD,CAAxB;AACA,WAAO,CAAC,OAAD,IAAY,SAAS,CAAC,QAAV,CAAmB,GAAnB,CAAnB;AACD,GAHM,CAAP;AAID,CATD;AAWA;;;;;;AAMG;;;AACH,OAAO,IAAM,sBAAsB,GAAoB,UAAC,EAAD,EAKtD;MAJC,WAAW,GAAA,EAAA,CAAA,W;MACX,QAAQ,GAAA,EAAA,CAAA,Q;MACR,iBAAiB,GAAA,EAAA,CAAA,iB;MACjB,gBAAgB,GAAA,EAAA,CAAA,gB;;AAEhB,MAAI,WAAW,IAAI,CAAC,iBAAhB,IAAqC,gBAAgB,KAAK,IAA9D,EAAoE;AAClE,WAAO,iBAAP;AACD;;AAED,MAAI,CAAC,gBAAL,EAAuB;AACrB,WAAO,EAAP;AACD;;AAED,MACE,gBAAgB,KAAK,aAArB,IACA,gBAAgB,KAAK,oBAFvB,EAGE;AACA,WAAO,aAAa,CAAC,QAAD,EAAW,gBAAgB,KAAK,oBAAhC,CAAb,GACH,iBADG,GAEH,EAFJ;AAGD;;AAED,MAAM,IAAI,GACR,OAAO,gBAAP,KAA4B,QAA5B,GACI,CAAC,gBAAD,CADJ,GAEI,gBAHN;AAKA,SAAO,IAAI,CAAC,MAAL,IACL,mBAAmB,CAAC,IAApB,CAAyB,UAAC,GAAD,EAAI;AAAK,WAAA,QAAQ,CAAC,GAAD,CAAR,IAAiB,IAAI,CAAC,QAAL,CAAjB,GAAiB,CAAjB;AAAmC,GAArE,CADK,GAEH,iBAFG,GAGH,EAHJ;AAID,CAhCM","sourceRoot":"","sourcesContent":["var __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\nvar VALIDITY_STATE_KEYS = [\n    \"badInput\",\n    \"customError\",\n    \"patternMismatch\",\n    \"rangeOverflow\",\n    \"rangeUnderflow\",\n    \"stepMismatch\",\n    \"tooLong\",\n    \"tooShort\",\n    \"typeMismatch\",\n    \"valueMissing\",\n];\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport var RECOMMENDED_STATE_KEYS = [\n    \"badInput\",\n    \"tooLong\",\n    \"valueMissing\",\n];\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport var RECOMMENDED_NUMBER_STATE_KEYS = __spreadArray(__spreadArray([], RECOMMENDED_STATE_KEYS), [\n    \"rangeOverflow\",\n    \"rangeUnderflow\",\n    \"tooShort\",\n    \"typeMismatch\",\n]);\n/**\n * The validation message is actually kind of weird since it's possible for a\n * form element to have multiple errors at once. The validation message will be\n * the first error that appears, so need to make sure that the first error is\n * one of the recommended state keys so the message appears for only those types\n * of errors.\n *\n * @internal\n * @remarks \\@since 2.5.0\n */\nvar isRecommended = function (validity, isNumber) {\n    var errorable = isNumber\n        ? RECOMMENDED_NUMBER_STATE_KEYS\n        : RECOMMENDED_STATE_KEYS;\n    return VALIDITY_STATE_KEYS.every(function (key) {\n        var errored = validity[key];\n        return !errored || errorable.includes(key);\n    });\n};\n/**\n * The default implementation for getting an error message for the `TextField`\n * or `TextArea` components that relies on the behavior of the\n * {@link ChangeValidationBehavior}\n *\n * @remarks \\@since 2.5.0\n */\nexport var defaultGetErrorMessage = function (_a) {\n    var isBlurEvent = _a.isBlurEvent, validity = _a.validity, validationMessage = _a.validationMessage, validateOnChange = _a.validateOnChange;\n    if (isBlurEvent || !validationMessage || validateOnChange === true) {\n        return validationMessage;\n    }\n    if (!validateOnChange) {\n        return \"\";\n    }\n    if (validateOnChange === \"recommended\" ||\n        validateOnChange === \"number-recommended\") {\n        return isRecommended(validity, validateOnChange === \"number-recommended\")\n            ? validationMessage\n            : \"\";\n    }\n    var keys = typeof validateOnChange === \"string\"\n        ? [validateOnChange]\n        : validateOnChange;\n    return keys.length &&\n        VALIDITY_STATE_KEYS.some(function (key) { return validity[key] && keys.includes(key); })\n        ? validationMessage\n        : \"\";\n};\n//# sourceMappingURL=getErrorMessage.js.map"]},"metadata":{},"sourceType":"module"}