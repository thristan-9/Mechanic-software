{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { applyRef, useDir, useIsomorphicLayoutEffect } from \"@react-md/utils\";\nimport { DEFAULT_SLIDER_ANIMATION_TIME } from \"./constants\";\nimport { getDragPercentage, getDragValue, isMouseEvent, isRangeSlider, isTouchEvent } from \"./utils\";\nvar VALID_KEYS = [\"ArrowDown\", \"ArrowUp\", \"ArrowLeft\", \"ArrowRight\", \"Home\", \"End\", \"PageUp\", \"PageDown\"];\n/**\n * This hook provides all the logic for updating the slider's when the user\n * intracts with the slider.\n *\n * @internal\n * @remarks \\@since 2.5.0\n */\n\nexport function useSliderControls(_a) {\n  var _b, _c;\n\n  var ref = _a.ref,\n      propThumb1Ref = _a.thumb1Ref,\n      propThumb2Ref = _a.thumb2Ref,\n      min = _a.min,\n      max = _a.max,\n      step = _a.step,\n      _d = _a.disabled,\n      disabled = _d === void 0 ? false : _d,\n      _e = _a.vertical,\n      vertical = _e === void 0 ? false : _e,\n      onBlur = _a.onBlur,\n      onKeyDown = _a.onKeyDown,\n      onMouseDown = _a.onMouseDown,\n      onTouchStart = _a.onTouchStart,\n      _f = _a.animationDuration,\n      animationDuration = _f === void 0 ? DEFAULT_SLIDER_ANIMATION_TIME : _f,\n      controls = __rest(_a, [\"ref\", \"thumb1Ref\", \"thumb2Ref\", \"min\", \"max\", \"step\", \"disabled\", \"vertical\", \"onBlur\", \"onKeyDown\", \"onMouseDown\", \"onTouchStart\", \"animationDuration\"]);\n\n  var trackRef = useRef(null);\n  var thumb1Ref = useRef(null);\n  var thumb2Ref = useRef(null);\n\n  var _g = useState(false),\n      dragging = _g[0],\n      setDragging = _g[1];\n\n  var _h = useState(min),\n      dragValue = _h[0],\n      setDragValue = _h[1];\n\n  var _j = useState(null),\n      draggingBy = _j[0],\n      setDraggingBy = _j[1];\n\n  var _k = useState(null),\n      draggingIndex = _k[0],\n      setDraggingIndex = _k[1];\n\n  var controlsRef = useRef(controls);\n  useIsomorphicLayoutEffect(function () {\n    controlsRef.current = controls;\n  });\n  var dir = useDir().dir;\n  var isRtl = dir === \"rtl\";\n  var thumb1Value;\n  var thumb1Percentage;\n  var thumb2Value;\n  var thumb2Percentage;\n\n  if (isRangeSlider(controls)) {\n    _b = controls.value, thumb1Value = _b[0], thumb2Value = _b[1];\n    _c = getDragPercentage({\n      min: min,\n      max: max,\n      thumb1Value: thumb1Value,\n      thumb2Value: thumb2Value,\n      dragging: dragging,\n      dragValue: dragValue,\n      draggingIndex: draggingIndex\n    }), thumb1Percentage = _c.thumb1Percentage, thumb2Percentage = _c.thumb2Percentage;\n  } else {\n    thumb1Value = controls.value;\n    thumb1Percentage = getDragPercentage({\n      min: min,\n      max: max,\n      thumb1Value: thumb1Value,\n      dragging: dragging,\n      dragValue: dragValue,\n      draggingIndex: draggingIndex\n    }).thumb1Percentage;\n  }\n  /**\n   * The main handler for updating the value of the slider. To help keep the\n   * drag experience smooth, some values are stored in refs to prevent the\n   * `useEffect` from being run during renders which adds and removes the move\n   * event handlers\n   */\n\n\n  var drag = useCallback(function (event) {\n    var track = trackRef.current;\n    var slider1 = thumb1Ref.current;\n    var slider2 = thumb2Ref.current;\n    var altKey = event.altKey,\n        ctrlKey = event.ctrlKey,\n        metaKey = event.metaKey,\n        shiftKey = event.shiftKey;\n\n    if (altKey || ctrlKey || metaKey || shiftKey || disabled || !track || !slider1 || isMouseEvent(event) && event.button !== 0 || isTouchEvent(event) && event.changedTouches.length !== 1 || !isMouseEvent(event) && !isTouchEvent(event)) {\n      return;\n    } // prevent text from being highlighted while dragging the slider\n    // can't do it on touch events due to being passive events in later\n    // versions of React\n\n\n    if (!isTouchEvent(event)) {\n      event.preventDefault();\n    }\n\n    event.stopPropagation(); // get the current mouse/touch position to help determine hwo far the\n    // slider is being dragged\n\n    var clientX;\n    var clientY;\n\n    if (isMouseEvent(event)) {\n      clientX = event.clientX, clientY = event.clientY;\n    } else {\n      var touch = event.changedTouches[0];\n      clientX = touch.clientX, clientY = touch.clientY;\n    }\n\n    var index = 0;\n    var slider = slider1;\n\n    if (slider2) {\n      // if we aren't dragging yet, try to find the slider closest to the\n      // mouse/touch position and use that one\n      if (draggingIndex === null) {\n        var x1 = slider1.getBoundingClientRect().x;\n        var x2 = slider2.getBoundingClientRect().x;\n        var y1 = slider1.getBoundingClientRect().y;\n        var y2 = slider2.getBoundingClientRect().y;\n\n        if (vertical) {\n          index = Math.abs(clientY - y1) < Math.abs(clientY - y2) ? 0 : 1;\n        } else {\n          index = Math.abs(clientX - x1) < Math.abs(clientX - x2) ? 0 : 1;\n        }\n      } else {\n        index = draggingIndex;\n      }\n\n      slider = index === 0 ? slider1 : slider2;\n    } // if we aren't dragging yet, want to focus the slider element to make it\n    // easier to switch between mouse dragging and keyboard \"dragging\"\n\n\n    if (draggingIndex !== index) {\n      slider.focus();\n      setDraggingIndex(index);\n    }\n\n    setDraggingBy(isMouseEvent(event) ? \"mouse\" : \"touch\");\n\n    var _a = track.getBoundingClientRect(),\n        left = _a.left,\n        top = _a.top,\n        height = _a.height,\n        width = _a.width;\n\n    var options = {\n      min: min,\n      max: max,\n      step: step,\n      vertical: vertical,\n      clientX: clientX,\n      clientY: clientY,\n      left: left,\n      top: top,\n      height: height,\n      width: width,\n      isRtl: isRtl,\n      minValue: min,\n      maxValue: max\n    };\n    var controls = controlsRef.current;\n\n    if (isRangeSlider(controls)) {\n      var _b = controls.value,\n          thumb1Value_1 = _b[0],\n          thumb2Value_1 = _b[1];\n\n      var _c = getDragValue(__assign(__assign({}, options), {\n        minValue: index === 0 ? min : thumb1Value_1 + step,\n        maxValue: index === 1 ? max : thumb2Value_1 - step\n      })),\n          value = _c.value,\n          current = _c.current;\n\n      setDragValue(current);\n      controls.setValue(index === 0 ? [value, thumb2Value_1] : [thumb1Value_1, value]);\n    } else {\n      var _d = getDragValue(options),\n          value = _d.value,\n          current = _d.current;\n\n      setDragValue(current);\n      controls.setValue(value);\n    }\n  }, [disabled, isRtl, draggingIndex, max, min, step, vertical]);\n  var stop = useCallback(function () {\n    controlsRef.current.persist();\n    setDragging(false);\n    setDraggingIndex(null);\n    setDraggingBy(null);\n  }, []);\n  useEffect(function () {\n    if (draggingBy === null) {\n      return;\n    }\n\n    if (draggingBy === \"mouse\") {\n      window.addEventListener(\"mousemove\", drag);\n      window.addEventListener(\"mouseup\", stop);\n    } else {\n      window.addEventListener(\"touchmove\", drag);\n      window.addEventListener(\"touchend\", stop);\n    }\n\n    return function () {\n      if (draggingBy === \"mouse\") {\n        window.removeEventListener(\"mousemove\", drag);\n        window.removeEventListener(\"mouseup\", stop);\n      } else {\n        window.removeEventListener(\"touchmove\", drag);\n        window.removeEventListener(\"touchend\", stop);\n      }\n    };\n  }, [draggingBy, drag, stop]);\n  useEffect(function () {\n    if (draggingIndex === null && draggingBy === null) {\n      return;\n    } // I don't know how to reach this flow.. so maybe can be removed?\n\n    /* istanbul ignore if */\n\n\n    if (draggingIndex === null) {\n      setDragging(false);\n      return;\n    }\n\n    var timeout = window.setTimeout(function () {\n      setDragging(true);\n    }, animationDuration);\n    return function () {\n      window.clearTimeout(timeout);\n    };\n  }, [draggingIndex, draggingBy, animationDuration]);\n  var handleBlur = useCallback(function (event) {\n    if (onBlur) {\n      onBlur(event);\n    }\n\n    controlsRef.current.persist();\n  }, [onBlur]);\n  /**\n   * Note: this should be attached to the `SliderTrack` component.\n   */\n\n  var handleMouseDown = useCallback(function (event) {\n    if (onMouseDown) {\n      onMouseDown(event);\n    } // only call drag again when the dragging by isn't null since it can cause\n    // the \"drag\" events to be re-started if the mouse appears over the slider\n    // thumb again\n\n\n    if (draggingBy === null) {\n      drag(event);\n    }\n  }, [drag, draggingBy, onMouseDown]);\n  /**\n   * Note: this should be attached to the `SliderTrack` component.\n   */\n\n  var handleTouchStart = useCallback(function (event) {\n    if (onTouchStart) {\n      onTouchStart(event);\n    } // only call drag again when the dragging by isn't null since it can cause\n    // the \"drag\" events to be re-started if the user's finger appears over\n    // the slider thumb again\n\n\n    if (draggingBy === null) {\n      drag(event);\n    }\n  }, [drag, draggingBy, onTouchStart]);\n  /**\n   * Note: this should be attached to each `SliderThumb` component.\n   */\n\n  var handleKeyDown = useCallback(function (event) {\n    if (onKeyDown) {\n      onKeyDown(event);\n    }\n\n    var key = event.key,\n        altKey = event.altKey,\n        ctrlKey = event.ctrlKey,\n        metaKey = event.metaKey,\n        shiftKey = event.shiftKey;\n\n    if (altKey || ctrlKey || metaKey || shiftKey || disabled || !VALID_KEYS.includes(key)) {\n      return;\n    }\n\n    var controls;\n\n    if (isRangeSlider(controlsRef.current)) {\n      var _a = controlsRef.current,\n          increment_1 = _a.increment,\n          incrementJump_1 = _a.incrementJump,\n          decrement_1 = _a.decrement,\n          decrementJump_1 = _a.decrementJump,\n          minimum_1 = _a.minimum,\n          maximum_1 = _a.maximum;\n      var index = event.currentTarget === thumb2Ref.current ? 1 : 0;\n      controls = {\n        increment: increment_1.bind(null, index),\n        incrementJump: incrementJump_1.bind(null, index),\n        decrement: decrement_1.bind(null, index),\n        decrementJump: decrementJump_1.bind(null, index),\n        minimum: minimum_1.bind(null, index),\n        maximum: maximum_1.bind(null, index)\n      };\n    } else {\n      controls = controlsRef.current;\n    }\n\n    var increment = controls.increment,\n        incrementJump = controls.incrementJump,\n        decrement = controls.decrement,\n        decrementJump = controls.decrementJump,\n        minimum = controls.minimum,\n        maximum = controls.maximum;\n    event.preventDefault();\n    event.stopPropagation();\n\n    switch (key) {\n      case \"ArrowUp\":\n      case \"ArrowRight\":\n        increment();\n        break;\n\n      case \"ArrowDown\":\n      case \"ArrowLeft\":\n        decrement();\n        break;\n\n      case \"Home\":\n        minimum();\n        break;\n\n      case \"End\":\n        maximum();\n        break;\n\n      case \"PageUp\":\n        incrementJump();\n        break;\n\n      case \"PageDown\":\n        decrementJump();\n        break;\n    }\n  }, [onKeyDown, disabled]);\n  var trackRefHandler = useCallback(function (instance) {\n    applyRef(instance, ref);\n    trackRef.current = instance;\n  }, [ref]);\n  var thumb1RefHandler = useCallback(function (instance) {\n    applyRef(instance, propThumb1Ref);\n    thumb1Ref.current = instance;\n  }, [propThumb1Ref]);\n  var thumb2RefHandler = useCallback(function (instance) {\n    applyRef(instance, propThumb2Ref);\n    thumb2Ref.current = instance;\n  }, [propThumb2Ref]);\n  return {\n    thumb1Ref: thumb1RefHandler,\n    thumb1Value: thumb1Value,\n    thumb1Percentage: thumb1Percentage,\n    thumb2Ref: thumb2RefHandler,\n    thumb2Value: thumb2Value,\n    thumb2Percentage: thumb2Percentage,\n    dragging: dragging,\n    draggingIndex: draggingIndex,\n    ref: trackRefHandler,\n    onBlur: handleBlur,\n    onKeyDown: handleKeyDown,\n    onMouseDown: handleMouseDown,\n    onTouchStart: handleTouchStart\n  };\n}","map":{"version":3,"sources":["../../src/slider/useSliderControls.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { useCallback, useEffect, useRef, useState, } from \"react\";\nimport { applyRef, useDir, useIsomorphicLayoutEffect } from \"@react-md/utils\";\nimport { DEFAULT_SLIDER_ANIMATION_TIME } from \"./constants\";\nimport { getDragPercentage, getDragValue, isMouseEvent, isRangeSlider, isTouchEvent, } from \"./utils\";\nvar VALID_KEYS = [\n    \"ArrowDown\",\n    \"ArrowUp\",\n    \"ArrowLeft\",\n    \"ArrowRight\",\n    \"Home\",\n    \"End\",\n    \"PageUp\",\n    \"PageDown\",\n];\n/**\n * This hook provides all the logic for updating the slider's when the user\n * intracts with the slider.\n *\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport function useSliderControls(_a) {\n    var _b, _c;\n    var ref = _a.ref, propThumb1Ref = _a.thumb1Ref, propThumb2Ref = _a.thumb2Ref, min = _a.min, max = _a.max, step = _a.step, _d = _a.disabled, disabled = _d === void 0 ? false : _d, _e = _a.vertical, vertical = _e === void 0 ? false : _e, onBlur = _a.onBlur, onKeyDown = _a.onKeyDown, onMouseDown = _a.onMouseDown, onTouchStart = _a.onTouchStart, _f = _a.animationDuration, animationDuration = _f === void 0 ? DEFAULT_SLIDER_ANIMATION_TIME : _f, controls = __rest(_a, [\"ref\", \"thumb1Ref\", \"thumb2Ref\", \"min\", \"max\", \"step\", \"disabled\", \"vertical\", \"onBlur\", \"onKeyDown\", \"onMouseDown\", \"onTouchStart\", \"animationDuration\"]);\n    var trackRef = useRef(null);\n    var thumb1Ref = useRef(null);\n    var thumb2Ref = useRef(null);\n    var _g = useState(false), dragging = _g[0], setDragging = _g[1];\n    var _h = useState(min), dragValue = _h[0], setDragValue = _h[1];\n    var _j = useState(null), draggingBy = _j[0], setDraggingBy = _j[1];\n    var _k = useState(null), draggingIndex = _k[0], setDraggingIndex = _k[1];\n    var controlsRef = useRef(controls);\n    useIsomorphicLayoutEffect(function () {\n        controlsRef.current = controls;\n    });\n    var dir = useDir().dir;\n    var isRtl = dir === \"rtl\";\n    var thumb1Value;\n    var thumb1Percentage;\n    var thumb2Value;\n    var thumb2Percentage;\n    if (isRangeSlider(controls)) {\n        _b = controls.value, thumb1Value = _b[0], thumb2Value = _b[1];\n        (_c = getDragPercentage({\n            min: min,\n            max: max,\n            thumb1Value: thumb1Value,\n            thumb2Value: thumb2Value,\n            dragging: dragging,\n            dragValue: dragValue,\n            draggingIndex: draggingIndex,\n        }), thumb1Percentage = _c.thumb1Percentage, thumb2Percentage = _c.thumb2Percentage);\n    }\n    else {\n        thumb1Value = controls.value;\n        (thumb1Percentage = getDragPercentage({\n            min: min,\n            max: max,\n            thumb1Value: thumb1Value,\n            dragging: dragging,\n            dragValue: dragValue,\n            draggingIndex: draggingIndex,\n        }).thumb1Percentage);\n    }\n    /**\n     * The main handler for updating the value of the slider. To help keep the\n     * drag experience smooth, some values are stored in refs to prevent the\n     * `useEffect` from being run during renders which adds and removes the move\n     * event handlers\n     */\n    var drag = useCallback(function (event) {\n        var track = trackRef.current;\n        var slider1 = thumb1Ref.current;\n        var slider2 = thumb2Ref.current;\n        var altKey = event.altKey, ctrlKey = event.ctrlKey, metaKey = event.metaKey, shiftKey = event.shiftKey;\n        if (altKey ||\n            ctrlKey ||\n            metaKey ||\n            shiftKey ||\n            disabled ||\n            !track ||\n            !slider1 ||\n            (isMouseEvent(event) && event.button !== 0) ||\n            (isTouchEvent(event) && event.changedTouches.length !== 1) ||\n            (!isMouseEvent(event) && !isTouchEvent(event))) {\n            return;\n        }\n        // prevent text from being highlighted while dragging the slider\n        // can't do it on touch events due to being passive events in later\n        // versions of React\n        if (!isTouchEvent(event)) {\n            event.preventDefault();\n        }\n        event.stopPropagation();\n        // get the current mouse/touch position to help determine hwo far the\n        // slider is being dragged\n        var clientX;\n        var clientY;\n        if (isMouseEvent(event)) {\n            (clientX = event.clientX, clientY = event.clientY);\n        }\n        else {\n            var touch = event.changedTouches[0];\n            (clientX = touch.clientX, clientY = touch.clientY);\n        }\n        var index = 0;\n        var slider = slider1;\n        if (slider2) {\n            // if we aren't dragging yet, try to find the slider closest to the\n            // mouse/touch position and use that one\n            if (draggingIndex === null) {\n                var x1 = slider1.getBoundingClientRect().x;\n                var x2 = slider2.getBoundingClientRect().x;\n                var y1 = slider1.getBoundingClientRect().y;\n                var y2 = slider2.getBoundingClientRect().y;\n                if (vertical) {\n                    index = Math.abs(clientY - y1) < Math.abs(clientY - y2) ? 0 : 1;\n                }\n                else {\n                    index = Math.abs(clientX - x1) < Math.abs(clientX - x2) ? 0 : 1;\n                }\n            }\n            else {\n                index = draggingIndex;\n            }\n            slider = index === 0 ? slider1 : slider2;\n        }\n        // if we aren't dragging yet, want to focus the slider element to make it\n        // easier to switch between mouse dragging and keyboard \"dragging\"\n        if (draggingIndex !== index) {\n            slider.focus();\n            setDraggingIndex(index);\n        }\n        setDraggingBy(isMouseEvent(event) ? \"mouse\" : \"touch\");\n        var _a = track.getBoundingClientRect(), left = _a.left, top = _a.top, height = _a.height, width = _a.width;\n        var options = {\n            min: min,\n            max: max,\n            step: step,\n            vertical: vertical,\n            clientX: clientX,\n            clientY: clientY,\n            left: left,\n            top: top,\n            height: height,\n            width: width,\n            isRtl: isRtl,\n            minValue: min,\n            maxValue: max,\n        };\n        var controls = controlsRef.current;\n        if (isRangeSlider(controls)) {\n            var _b = controls.value, thumb1Value_1 = _b[0], thumb2Value_1 = _b[1];\n            var _c = getDragValue(__assign(__assign({}, options), { minValue: index === 0 ? min : thumb1Value_1 + step, maxValue: index === 1 ? max : thumb2Value_1 - step })), value = _c.value, current = _c.current;\n            setDragValue(current);\n            controls.setValue(index === 0 ? [value, thumb2Value_1] : [thumb1Value_1, value]);\n        }\n        else {\n            var _d = getDragValue(options), value = _d.value, current = _d.current;\n            setDragValue(current);\n            controls.setValue(value);\n        }\n    }, [disabled, isRtl, draggingIndex, max, min, step, vertical]);\n    var stop = useCallback(function () {\n        controlsRef.current.persist();\n        setDragging(false);\n        setDraggingIndex(null);\n        setDraggingBy(null);\n    }, []);\n    useEffect(function () {\n        if (draggingBy === null) {\n            return;\n        }\n        if (draggingBy === \"mouse\") {\n            window.addEventListener(\"mousemove\", drag);\n            window.addEventListener(\"mouseup\", stop);\n        }\n        else {\n            window.addEventListener(\"touchmove\", drag);\n            window.addEventListener(\"touchend\", stop);\n        }\n        return function () {\n            if (draggingBy === \"mouse\") {\n                window.removeEventListener(\"mousemove\", drag);\n                window.removeEventListener(\"mouseup\", stop);\n            }\n            else {\n                window.removeEventListener(\"touchmove\", drag);\n                window.removeEventListener(\"touchend\", stop);\n            }\n        };\n    }, [draggingBy, drag, stop]);\n    useEffect(function () {\n        if (draggingIndex === null && draggingBy === null) {\n            return;\n        }\n        // I don't know how to reach this flow.. so maybe can be removed?\n        /* istanbul ignore if */\n        if (draggingIndex === null) {\n            setDragging(false);\n            return;\n        }\n        var timeout = window.setTimeout(function () {\n            setDragging(true);\n        }, animationDuration);\n        return function () {\n            window.clearTimeout(timeout);\n        };\n    }, [draggingIndex, draggingBy, animationDuration]);\n    var handleBlur = useCallback(function (event) {\n        if (onBlur) {\n            onBlur(event);\n        }\n        controlsRef.current.persist();\n    }, [onBlur]);\n    /**\n     * Note: this should be attached to the `SliderTrack` component.\n     */\n    var handleMouseDown = useCallback(function (event) {\n        if (onMouseDown) {\n            onMouseDown(event);\n        }\n        // only call drag again when the dragging by isn't null since it can cause\n        // the \"drag\" events to be re-started if the mouse appears over the slider\n        // thumb again\n        if (draggingBy === null) {\n            drag(event);\n        }\n    }, [drag, draggingBy, onMouseDown]);\n    /**\n     * Note: this should be attached to the `SliderTrack` component.\n     */\n    var handleTouchStart = useCallback(function (event) {\n        if (onTouchStart) {\n            onTouchStart(event);\n        }\n        // only call drag again when the dragging by isn't null since it can cause\n        // the \"drag\" events to be re-started if the user's finger appears over\n        // the slider thumb again\n        if (draggingBy === null) {\n            drag(event);\n        }\n    }, [drag, draggingBy, onTouchStart]);\n    /**\n     * Note: this should be attached to each `SliderThumb` component.\n     */\n    var handleKeyDown = useCallback(function (event) {\n        if (onKeyDown) {\n            onKeyDown(event);\n        }\n        var key = event.key, altKey = event.altKey, ctrlKey = event.ctrlKey, metaKey = event.metaKey, shiftKey = event.shiftKey;\n        if (altKey ||\n            ctrlKey ||\n            metaKey ||\n            shiftKey ||\n            disabled ||\n            !VALID_KEYS.includes(key)) {\n            return;\n        }\n        var controls;\n        if (isRangeSlider(controlsRef.current)) {\n            var _a = controlsRef.current, increment_1 = _a.increment, incrementJump_1 = _a.incrementJump, decrement_1 = _a.decrement, decrementJump_1 = _a.decrementJump, minimum_1 = _a.minimum, maximum_1 = _a.maximum;\n            var index = event.currentTarget === thumb2Ref.current ? 1 : 0;\n            controls = {\n                increment: increment_1.bind(null, index),\n                incrementJump: incrementJump_1.bind(null, index),\n                decrement: decrement_1.bind(null, index),\n                decrementJump: decrementJump_1.bind(null, index),\n                minimum: minimum_1.bind(null, index),\n                maximum: maximum_1.bind(null, index),\n            };\n        }\n        else {\n            controls = controlsRef.current;\n        }\n        var increment = controls.increment, incrementJump = controls.incrementJump, decrement = controls.decrement, decrementJump = controls.decrementJump, minimum = controls.minimum, maximum = controls.maximum;\n        event.preventDefault();\n        event.stopPropagation();\n        switch (key) {\n            case \"ArrowUp\":\n            case \"ArrowRight\":\n                increment();\n                break;\n            case \"ArrowDown\":\n            case \"ArrowLeft\":\n                decrement();\n                break;\n            case \"Home\":\n                minimum();\n                break;\n            case \"End\":\n                maximum();\n                break;\n            case \"PageUp\":\n                incrementJump();\n                break;\n            case \"PageDown\":\n                decrementJump();\n                break;\n        }\n    }, [onKeyDown, disabled]);\n    var trackRefHandler = useCallback(function (instance) {\n        applyRef(instance, ref);\n        trackRef.current = instance;\n    }, [ref]);\n    var thumb1RefHandler = useCallback(function (instance) {\n        applyRef(instance, propThumb1Ref);\n        thumb1Ref.current = instance;\n    }, [propThumb1Ref]);\n    var thumb2RefHandler = useCallback(function (instance) {\n        applyRef(instance, propThumb2Ref);\n        thumb2Ref.current = instance;\n    }, [propThumb2Ref]);\n    return {\n        thumb1Ref: thumb1RefHandler,\n        thumb1Value: thumb1Value,\n        thumb1Percentage: thumb1Percentage,\n        thumb2Ref: thumb2RefHandler,\n        thumb2Value: thumb2Value,\n        thumb2Percentage: thumb2Percentage,\n        dragging: dragging,\n        draggingIndex: draggingIndex,\n        ref: trackRefHandler,\n        onBlur: handleBlur,\n        onKeyDown: handleKeyDown,\n        onMouseDown: handleMouseDown,\n        onTouchStart: handleTouchStart,\n    };\n}\n//# sourceMappingURL=useSliderControls.js.map"]},"metadata":{},"sourceType":"module"}