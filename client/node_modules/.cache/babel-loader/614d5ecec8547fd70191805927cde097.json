{"ast":null,"code":"import { useState } from \"react\";\n/**\n * This hook allows you to toggle the state of multiple checkboxes in a single\n * place along with an indeterminate checkbox that can check/uncheck all\n * checkboxes at once.\n *\n * ### Examples:\n *\n * #### Simple value list with labels lookup:\n *\n * ```tsx\n * const values = [\"a\", \"b\", \"c\", \"d\"];\n * const LABELS = { a: \"Label 1\", b: \"Label 2\", c: \"Label 3\", d: \"Label 4\" };\n * const { getProps, rootProps } = useIndeterminateChecked(values);\n *\n * return (\n *   <>\n *     <Checkbox id=\"root-checkbox\" {...rootProps} label=\"Root Checkbox\" />\n *     {values.map((value, i) => (\n *       <Checkbox\n *         id={`child-checkbox-${i + 1}`}\n *         label={LABELS[value]}\n *         {...getProps(value)}\n *       />\n *     ))}\n *   </>\n * );\n * ```\n *\n * #### Fetch Data From Server and check first result\n * ```tsx\n * interface ServerFetchedData {\n *   id: Guid;\n *   name: string;\n * }\n *\n *\n * const [data, setData] = useState<ServerFetchedData[]>([]);\n * const { getProps, rootProps, setCheckedValues } = useIndeterminateChecked(\n *   data.map(({ id }) => id),\n * );\n *\n * useEffect(() => {\n *   let cancelled = false;\n *   (async function load() {\n *     const response = await fetch(\"/my-api\");\n *     const json = await response.json();\n *     if (!cancelled) {\n *       // pretend validation and sanity checks\n *       setData(json as ServerFetchedData[]);\n *       setCheckedValues(json[0].id);\n *     }\n *   })();\n\n *   return () => {\n *     cancelled = true;\n *   };\n * }, []);\n *\n * return (\n *   <>\n *     <Checkbox id=\"root-checkbox\" {...rootProps} label=\"Root Checkbox\" />\n *     {data.map(({ id, name }, i) => (\n *       <Checkbox\n *         id={`child-checkbox-${i + 1}`}\n *         label={name}\n *         {...getProps(id)}\n *       />\n *     ))}\n *   </>\n * );\n * ```\n *\n * @param values - All the checkbox values that the indeterminate checkbox can\n * control. The values will **need** to be unique as they are passed to each\n * checkbox to determine if it is checked or not. This will directly map to\n * the `value` attribute for each checkbox.\n * @param defaultCheckedValues - An optional list of all the values that are\n * checked on first render. Changing this value will not update the checked\n * values.\n * @param onChange - An optional function to call whenever the checked values\n * list updates that will provide the next list of all the checked values. This\n * isn't a super helpful prop since this hook will always return the checked\n * values anyways.\n * @returns An object containing a function to get the props for each controlled\n * checkbox, the props for the root indeterminate checkbox, a list of all the\n * checked values, and a general `setCheckboxValues` function from `useState` if\n * the list of values can be changed from external sources as well.\n */\n\nexport function useIndeterminateChecked(values, defaultCheckedValues, onChange) {\n  if (defaultCheckedValues === void 0) {\n    defaultCheckedValues = [];\n  }\n\n  var _a = useState(defaultCheckedValues),\n      checkedValues = _a[0],\n      setCheckedValues = _a[1];\n\n  var checked = checkedValues.length > 0;\n  var indeterminate = checked && checkedValues.length < values.length;\n\n  var updateCheckedValues = function (values) {\n    if (onChange) {\n      onChange(values);\n    }\n\n    setCheckedValues(values);\n  };\n\n  var rootProps = {\n    \"aria-checked\": indeterminate ? \"mixed\" : undefined,\n    checked: checked,\n    indeterminate: indeterminate,\n    onChange: function () {\n      return updateCheckedValues(checkedValues.length === 0 || indeterminate ? values : []);\n    }\n  };\n\n  var getProps = function (value) {\n    return {\n      value: value,\n      checked: checkedValues.includes(value),\n      onChange: function () {\n        var i = checkedValues.indexOf(value);\n        var nextChecked = checkedValues.slice();\n\n        if (i === -1) {\n          nextChecked.push(value);\n        } else {\n          nextChecked.splice(i, 1);\n        }\n\n        updateCheckedValues(nextChecked);\n      }\n    };\n  };\n\n  return {\n    getProps: getProps,\n    rootProps: rootProps,\n    checkedValues: checkedValues,\n    setCheckedValues: setCheckedValues\n  };\n}","map":{"version":3,"sources":["../src/useIndeterminateChecked.ts"],"names":[],"mappings":"AAAA,SAAmC,QAAnC,QAAmD,OAAnD;AAwCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuFG;;AACH,OAAM,SAAU,uBAAV,CACJ,MADI,EAEJ,oBAFI,EAGJ,QAHI,EAGmC;AADvC,MAAA,oBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,oBAAA,GAAA,EAAA;AAA4C;;AAGtC,MAAA,EAAA,GAAoC,QAAQ,CAAM,oBAAN,CAA5C;AAAA,MAAC,aAAa,GAAA,EAAA,CAAA,CAAA,CAAd;AAAA,MAAgB,gBAAgB,GAAA,EAAA,CAAA,CAAA,CAAhC;;AACN,MAAM,OAAO,GAAG,aAAa,CAAC,MAAd,GAAuB,CAAvC;AACA,MAAM,aAAa,GAAG,OAAO,IAAI,aAAa,CAAC,MAAd,GAAuB,MAAM,CAAC,MAA/D;;AAEA,MAAM,mBAAmB,GAAG,UAAC,MAAD,EAAY;AACtC,QAAI,QAAJ,EAAc;AACZ,MAAA,QAAQ,CAAC,MAAD,CAAR;AACD;;AAED,IAAA,gBAAgB,CAAC,MAAD,CAAhB;AACD,GAND;;AAQA,MAAM,SAAS,GAAuC;AACpD,oBAAgB,aAAa,GAAG,OAAH,GAAa,SADU;AAEpD,IAAA,OAAO,EAAA,OAF6C;AAGpD,IAAA,aAAa,EAAA,aAHuC;AAIpD,IAAA,QAAQ,EAAE,YAAA;AACR,aAAA,mBAAmB,CACjB,aAAa,CAAC,MAAd,KAAyB,CAAzB,IAA8B,aAA9B,GAA8C,MAA9C,GAAuD,EADtC,CAAnB;AAEC;AAPiD,GAAtD;;AAUA,MAAM,QAAQ,GAA+C,UAAC,KAAD,EAAM;AAAK,WAAC;AACvE,MAAA,KAAK,EAAA,KADkE;AAEvE,MAAA,OAAO,EAAE,aAAa,CAAC,QAAd,CAAuB,KAAvB,CAF8D;AAGvE,MAAA,QAAQ,EAAE,YAAA;AACR,YAAM,CAAC,GAAG,aAAa,CAAC,OAAd,CAAsB,KAAtB,CAAV;AACA,YAAM,WAAW,GAAG,aAAa,CAAC,KAAd,EAApB;;AACA,YAAI,CAAC,KAAK,CAAC,CAAX,EAAc;AACZ,UAAA,WAAW,CAAC,IAAZ,CAAiB,KAAjB;AACD,SAFD,MAEO;AACL,UAAA,WAAW,CAAC,MAAZ,CAAmB,CAAnB,EAAsB,CAAtB;AACD;;AAED,QAAA,mBAAmB,CAAC,WAAD,CAAnB;AACD;AAbsE,KAAD;AActE,GAdF;;AAgBA,SAAO;AACL,IAAA,QAAQ,EAAA,QADH;AAEL,IAAA,SAAS,EAAA,SAFJ;AAGL,IAAA,aAAa,EAAA,aAHR;AAIL,IAAA,gBAAgB,EAAA;AAJX,GAAP;AAMD","sourceRoot":"","sourcesContent":["import { useState } from \"react\";\n/**\n * This hook allows you to toggle the state of multiple checkboxes in a single\n * place along with an indeterminate checkbox that can check/uncheck all\n * checkboxes at once.\n *\n * ### Examples:\n *\n * #### Simple value list with labels lookup:\n *\n * ```tsx\n * const values = [\"a\", \"b\", \"c\", \"d\"];\n * const LABELS = { a: \"Label 1\", b: \"Label 2\", c: \"Label 3\", d: \"Label 4\" };\n * const { getProps, rootProps } = useIndeterminateChecked(values);\n *\n * return (\n *   <>\n *     <Checkbox id=\"root-checkbox\" {...rootProps} label=\"Root Checkbox\" />\n *     {values.map((value, i) => (\n *       <Checkbox\n *         id={`child-checkbox-${i + 1}`}\n *         label={LABELS[value]}\n *         {...getProps(value)}\n *       />\n *     ))}\n *   </>\n * );\n * ```\n *\n * #### Fetch Data From Server and check first result\n * ```tsx\n * interface ServerFetchedData {\n *   id: Guid;\n *   name: string;\n * }\n *\n *\n * const [data, setData] = useState<ServerFetchedData[]>([]);\n * const { getProps, rootProps, setCheckedValues } = useIndeterminateChecked(\n *   data.map(({ id }) => id),\n * );\n *\n * useEffect(() => {\n *   let cancelled = false;\n *   (async function load() {\n *     const response = await fetch(\"/my-api\");\n *     const json = await response.json();\n *     if (!cancelled) {\n *       // pretend validation and sanity checks\n *       setData(json as ServerFetchedData[]);\n *       setCheckedValues(json[0].id);\n *     }\n *   })();\n\n *   return () => {\n *     cancelled = true;\n *   };\n * }, []);\n *\n * return (\n *   <>\n *     <Checkbox id=\"root-checkbox\" {...rootProps} label=\"Root Checkbox\" />\n *     {data.map(({ id, name }, i) => (\n *       <Checkbox\n *         id={`child-checkbox-${i + 1}`}\n *         label={name}\n *         {...getProps(id)}\n *       />\n *     ))}\n *   </>\n * );\n * ```\n *\n * @param values - All the checkbox values that the indeterminate checkbox can\n * control. The values will **need** to be unique as they are passed to each\n * checkbox to determine if it is checked or not. This will directly map to\n * the `value` attribute for each checkbox.\n * @param defaultCheckedValues - An optional list of all the values that are\n * checked on first render. Changing this value will not update the checked\n * values.\n * @param onChange - An optional function to call whenever the checked values\n * list updates that will provide the next list of all the checked values. This\n * isn't a super helpful prop since this hook will always return the checked\n * values anyways.\n * @returns An object containing a function to get the props for each controlled\n * checkbox, the props for the root indeterminate checkbox, a list of all the\n * checked values, and a general `setCheckboxValues` function from `useState` if\n * the list of values can be changed from external sources as well.\n */\nexport function useIndeterminateChecked(values, defaultCheckedValues, onChange) {\n    if (defaultCheckedValues === void 0) { defaultCheckedValues = []; }\n    var _a = useState(defaultCheckedValues), checkedValues = _a[0], setCheckedValues = _a[1];\n    var checked = checkedValues.length > 0;\n    var indeterminate = checked && checkedValues.length < values.length;\n    var updateCheckedValues = function (values) {\n        if (onChange) {\n            onChange(values);\n        }\n        setCheckedValues(values);\n    };\n    var rootProps = {\n        \"aria-checked\": indeterminate ? \"mixed\" : undefined,\n        checked: checked,\n        indeterminate: indeterminate,\n        onChange: function () {\n            return updateCheckedValues(checkedValues.length === 0 || indeterminate ? values : []);\n        },\n    };\n    var getProps = function (value) { return ({\n        value: value,\n        checked: checkedValues.includes(value),\n        onChange: function () {\n            var i = checkedValues.indexOf(value);\n            var nextChecked = checkedValues.slice();\n            if (i === -1) {\n                nextChecked.push(value);\n            }\n            else {\n                nextChecked.splice(i, 1);\n            }\n            updateCheckedValues(nextChecked);\n        },\n    }); };\n    return {\n        getProps: getProps,\n        rootProps: rootProps,\n        checkedValues: checkedValues,\n        setCheckedValues: setCheckedValues,\n    };\n}\n//# sourceMappingURL=useIndeterminateChecked.js.map"]},"metadata":{},"sourceType":"module"}